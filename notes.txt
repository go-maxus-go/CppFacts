1) тип результата
int / float result type? float
int * float? result type? float
1.0 type? double
1.f type? float

2) struct A { virtual void Do(int = 0){ std::cout<<"A";}};
struct B : A { virtual void Do(int){ std::cout<<"B";}};
B b;
(A&)(b).Do();
Будет вызов B.Do(0)

3) struct A { explicit A(int){} };
std::vector<A> arr;
arr.emplace_back(42);
Создаст элемент в векторе, push_back не создаст.

4) std:: string str = "hello" - литерал
char c = 'A' - символьная константа

5) struct A { virtual Do() {std::cout << "A"; }};
struct B : A { Do() {std::cout << "B"; }};
struct C : B { Do() override {std::cout << "C"; }};
B * b = new C;
A * a = b;
a->Do(); // C
b->Do(); // C

6) std::vector<int> v1(10);
auto v2 = std::move(v1);
assert(v1.empty());
assert(v2.size() == 10);

7) std::string().c_str(); // получение C - строки (ограниченной нулем)

8) std::vector<int> v1[1000] vs std::vector<int> v2(1000)
[] - массив векторов, () - вектор с 1000 пустых элементов

9) bool, int, char - интегральные типы
интегральные + float, double - арифметические типы
class, struct, enum, enum class - пользовательские
void, void *, int &, float && - встроенные типы

10) bool преобразуется в int // false => 0, true => 1
и наоборот // false => 0, true => 1

11) auto c = L'ab'; // у меня не скомпилировалось, error C2220: warning treated as error - no 'object' file generated

12) char практически всегда 8бит, но могут быть исключения

13) 0x0123abc // шестнадцатиричный литерал
01234567 // восьмеричный литерал
123456789 // десятичный литерал
0.1f // float 0.1
0.1 // double 0.1
1.23e-1f // float
1.23e8L // long double

14) U, L - суффиксы определяют unsigned и long
1L - long 1, 2U - unsigned int 2, 3UL - unsigned long

15) все размеры типов измеряются в char, char берется за 1

16) фундаментальные типы преобразуются без потери информации, также могут преобразовываться и с потерей.

17) enum { Red, Green, Blue} // можно записывать без названия
enum State { Invalid = 1, Valid = 2, Downloaded = 4} // можно записать как флаг, State s = State(Valid | Downloaded);
enum Smth { A = -5, B = -10, C = 8} // можно задавать отрицательные значения
у енума есть диапазон, такой чтобы влезли все возможные флаги, в плюс и в минус относительно нуля.

18) extern int a; // предекларация глобальной переменной?

19) class A {}; int main() { class A; class A; } // успешно скомпилируется

20) любое объявление в котором указывается значение является определением

21) int* p, a; // *p, a
int a[10], *p[]; // a[10], *p[]

22) extern "C" void f();
Отключает механизм декорации имени, чтобы фукнцию можно было запаковать в *.obj
файл и сохранить при это обратную совместимость с языками C и прочими древними.
Переопредилить такую функцию нельзя, потому что возникнет конфликт имен (будет
две функции с одинаковым именем, а mangling отключен)

23) ключевое слово Extern - используется при объявлении переменной определенной
где-то в другом модуле, для того чтобы у ней можно было получить доступ.

24) int d[] = {0, 1, 2, 3};
int * p = d;
d = p; // error
массив можно неавно привести к указателью на его первый элемент, при этом теряя
его длину, обратно этого сделать нельзя

25) операция сложения указателей смысла не имеет и поэтому запрещена.

26) struct A { void Do() {} };
template<class T>
struct B
{
void Do() { t.Do(); }
void Bo() { t.Bo(); }
T t;
};
int main()
{
B<A> b;
b.Do();
}

Скомпилируется нормально, потому что функция Bo() будет сгенерирована только
если она будет где-то вызываться.

27) struct A {
// компилятор может запретить вызов чисто виртуального метода в конструкторе
A(){ PureVirtualFunctionCall(); } 
virtual void Do() = 0;
void PureVirtualFunctionCall() { Do(); } // вызов чисто абстрактного метода
};
struct B : A { void Do() override {} };

int main() {B b;} // получаем ошибку рантайма Pure virtual function call

28)
struct A
{
void a() {std::cout << "A::a" << std::endl;}
virtual void b() {std::cout <<"A::b" << std::endl;}
};
struct B : A
{
virtual void a() {std::cout << "B::a" << std::endl;}
void b() {std::cout <<"B::b" << std::endl;}
};
int main(int argc, char *argv[])
{
B b;
A &a = b;
a.a(); // A::a
a.b(); // B::b
b.a(); // B::a
b.b(); // B::b
}

29) struct A{ void Do(); };
struct B {virtual void Do(); };
struct C : A, B {void Do() };
sizeof(A), sizeof(B), sizeof(C) - ?

30) struct A {virtual ~A = default;}
struct B: A {};
B b;
При создании A ее указатель на таблицу виртуальных функций указывает собственную
таблицу, когда А будет полностью инициализирована указатель будет указывать на
таблицу виртуальных функций B.

31) struct A
{
A() { std::cout << "A"; throw std::exception(); } // нужно проверить синтаксиc
~A() { std::cout << "~A"; }
}
До тело деструктора не будет вызвано, потому что объект А не будет считаться
созданным. Все его поля будут уничтожаться в порядке LIFO.

32) Зависит ли размер структуры от порядка полей?
struct A{ char a, int b, char c };
struct B{ char a, char c, int b };
Во втором случае размер будет меньше, потому что B.a и B.b упакуются вместе.

33) у класса есть только один указатель на таблицу виртуальных функций,
если где-то в иерархии наследования есть класс с виртуальными функциями,
то все его потомки тоже будут обладать таблицей виртуальных функций.

34) Читать такие выражения справа налево:
char * const p; // p - константный указатель на char
char const * p; // p - указатель на константный char
const char * p; // p - указатель на константный char
2 и 3 - эквивалентны

35) модификатор const - изменяет тип, накладывая на него ограничения

36) обращение к функции по ее имени эквивалентно обращению по указателю

37) обычный указатель можно присвоить константному, а наоборот нельзя.
chat * p;
const char * pc;
pc = p; // ok
p = pc; // compile time error

38) ссылки обязаны быть инициализированы при объявлении, поэтому нет массивов из ссылок.

39) extern int &r; // возможна такая запись
extern может использоваться как предекларация переменных.
Если переменная объявлена в одном модуле, ее значение используется в заголовке класса,
то нужно предекларировать эту переменную со словом extern. иначе произойдет ошибка линковки.

40) ссылка - это альтернативное значение переменной, может быть реализовано через константный
указатель, за исключением того, что над ссылкой нельзя проводить никакие операции.

41) константные ссылки, продлевают жизнь временным объектам.
double & dr = 1; // error, нужен lvalue
const double & cdr = 1; // fine, создается временный объект типа double, а единица используется как инициализатор

42) int & f(int & v) { return v; }
int v = 0;
f(v)++;
std::cout << v; // v = 1, в целом очевидно, просто чтобы знать что так можно записать.

43) В void * можно преобразовать любой тип, из void * только через static_cast
разыменовать нельзя, никакие операции проводить нельзя.
Указатели на члены и на функции не могут быть присвоены переменным void * ?
Мне компилятор разрешил.

44) struct stat {};
int stat();
enum stat {...};
union stat{...};
Такая перегрузка имен возможна, уходит корнями в Си. Не рекомендуется так делать.

45) int (&r)[10]; // ссылка на массив из 10-ти char'ов
char *(*data)[]; // указатель на массив строк(char*)
typedef char (*tt)[8]; // tt - указатель на массив из 8-ми char
typedef int (*(tt[8]))[7]; // tt - массив из 8-ми массивов указателей на целое

46) когда имеет смысл воспользоваться именем в его собственном инициализаторе?
struct A { int v; A(int v): v(v) {} };

47) С не есть подмножество С++, большинство программ С будет совместимо с С++,
но есть часть которая не будет.
int virtual = 0; // virtual - ключевое слово
int class = 0; // class - ключевое слово
int * data = malloc(100 * sizeof(int)); // void * нельзя неявно привести к другому указателю в С++

48) C++11 если объявлено одно из следующих:
деструктор/копи-конструктор/мув-конструктор/оператор присвоения/оператор перемещения
то рекомендуется объявить остальные операции, часть из них не будет сгенерировано.
Некоторые могут быть сгенерированы, но это устаревшее поведение.
Если объявить оператор копирования, то перемещение будет запрещено и конструктор копирования должен быть запрещен.
Если объявить оператор перемещения, то оператор копирования будет запрещен, и конструктор копирования тоже должен быть запрещен. 
Если объявить деструктор, то перемещение и копирование запрещено.

49) C++11 enum class : int { A, B};
В новых классах перечислений можно указывать от какого они типа,
чтобы использовать их как флаги нужно самостоятельно определять операторы |=, &=

50) const vs constexpt
const - говорит о том, что объект не может быть изменен через данный интерфейс,
компилятор может оптимизировать константные переменные, помещая их в свои таблицы,
и не создавая эти переменные в коде
constexpr - говорит о том что данное выражение может быть вычислено на этапе компиляции,
и его значение компилятору нужно разместить в таблице.
очевидно, что не каждое выражение может быть вычислено на этапе компиляции.

51) decltype(1 * 1.0) a; // a типа double
decltype - декларация типа как результат некоторого выражиния, часто можно заменить словом auto.
decltype принимает только объекты, нельзя через него задать тип через другие типы.

52) std::initializer_list<T> - список, с помощью которого можно инициализировать объект.
std::vector v {0, 1, 2};
v = {4, 5};
void f(const std::list &);
f({7, 8, 9});

53) список инициализации предотвращает сужение типов.
char c = {256}; // ошибка, 256 вне диапазона char
vector<int> v = {1, 2.5}; // сужение int -> double, должна быть ошибка компиляции, но я видел просто ворнинг
Похоже что из-за того что список инициализации шаблонный возможна такая проверка.

54) вызов чисто виртуального метода разрешен в конструкторе, компиляторы как правило не ругаются.

55) Если в наследнике функция перекрывается переменной, то через using нельзя обратиться к функции
struct A { void f(){} };
class B : A { int f{0}; public: using B::f; };
int main() { B().f(); }
Если функция перекрывается функцией, то можно обратиться.
В С++ 11 теперь можно таким же образом объявлять конструктор базового класса в наследнике.

56) argc - количество переданных параметров. argv - аргументы, первый - имя программы
argv[argc] == 0; // это выполняется всегда.

57) std::cout, std::cerr, std::clog - разные стримы, первый для вывода программы,
второй для вывода ошибок, третий для логов. Каждым из них можно управлять независимо.
вывод первого можно направить в файл, второго оставить в консоль, вывод третьего в другой
файл. std::cerr пишет без буфера, то есть сразу же в конечный вывод.

58) #include <typeinfo>
typeid - возвращает структуру type_info, которая содержит имя типа и хеш-сумму
для выявления типа идет обращение к статичной структуре, которая содержит эту инфу.
Для полиморфных объектов возвращается тип реального объекта, видимо эта информация
берется из обращения к таблице виртуальных функций.
struct Base2 { virtual void foo() {} }; // polymorphic
struct Derived2 : Base2 {};
Derived d;
Base& b = d;
std::cout << typeid(b).name(); // Derived, из-за vtable!!!

59) int v = 15; std::cout << ~v; // -16, инверсия каждого бита

60) operator ->* and .* - вызов функции члена класса
#include <iostream>

class A {
int f() { return 1; }
public:
A() : x(&A::f) {}
	int (A::*x)();
};

int main() {
A a;
std::cout << (a.*a.x)();
	return 0;
}

61) long long - по меньшей мере 64 бита

62) в чем проблема данного выражения?
template<class T, class U>
decltype(x*y) mul(T x, U y) // Проблема с видимостью!
{
return x*y;
}
нужно заменить decltype на auto // C++17
нужно добавить суффикс указывающий на возвращаемое значение // C++11

63) как в С++ 11 можно решать проблему области видимости
struct A
{
struct B {};
B give();
};

auto A::give() -> B // так можно писать вместо A::B A::give()
{
return B();
}

64) C++ 11 template alias  ???

65) variadic templates - шаблоны со списком аргументов.
Для обработки этих аргументов нужно определить общий класс или метод,
а затем вызывать себя рекурсивно до тех пор, пока не закончатся аргументы.
Когда закончатся аргументы должен произойти последний вызов.
Напоминает функциональное программирование. Пример сумматора:
#include <iostream>

template<class VALUE, class... ARGS >
VALUE sum(VALUE value, ARGS... args)
	{ return value + sum(args...); }
	
	int sum() { return 0; }
	
	int main()
{
std::cout << sum(1, 2, 3, 4, 5) << std::endl;
}
ARGS - состоит из пар тип + значение, при рекурсивном вызове доходит до нуля.

на этом же принципе построен tuple, только он производит наследование сам от себя
рекурсивно. Чем больше аргументов тем больше уровень наследования.
так-как большинство типов можно будет вывести для создания tuple используется функция
make_tuple, она принимает на вход переменное число аргументов и создает по ним tuple.

66) Цель стандартных арифметических преобразований типов сводится к получению
"наибольшего" типа. Например float * int будет float. Операнды которые по размеру меньше int
до исполнения оператора переводятся в int. как правило если на вход оператору
предоставляется lvalue, то результат будет тоже lvalue.
int x = 0;
int y = 0;
int p = x = y;
int * p1 = &(x++); // результатом будет временный объект, нельзя брать его ссылку.
int * p2 = &(x > y ? x : y);

67) если число становится больше своего максимума, то поведение не определено!!!
тоже самое если делить на ноль. при этом программа аварийно завершается, без
генерации стандартных исключений.

68) порядок вычисления подвыражений внутри выражения не определен.
int i = 1;
v[i] = i++;
получистся либо v[1] = 1; v[2] = 2; неизвестно какая часть выражения выполнится раньше
только операторы , && || гарантируют что сначала вычислится выражение слева, а потом справа.

69) std::vector<bool> - упакован для экономии памяти, с ним нужно быть аккуратным
напрямую доступиться к элементы такого вектора нельзя, для этого есть специальные
сылки. но эти ссылки лишь ведут себя похожим образом. поэтому с ним не будут работать
стандартные алгоритмы и много чего другого.
std::bitset - массив из битов, упакован для экономии памяти

70) оператор new выделяет памяти чуть больше, как правило больше на одно слово,
чтобы знать размер выделенной памяти. если был создан объект, то его нужно удалять
через delete, если массив, то через delete[]

71) операторы new, new[] при неудачном выделении памяти кидают исключение bad_alloc,
можно задать обработчик для такой ситуации, типа set_new_handler([](){ throw std::bad_alloc; })
в этом обработчике можно делать дополнительные действия.
Есть возможность переопределить операторы new, new[] таким образом чтобы не было необходимости вызова 
операторов delete, delete[] (реализовать сборку мусора.)

72) знает ли компилятор тип на который указывает void* ?
нет не знает.

73) const_cast - убирает const и volatile, очевидно на этапе компиляции.
static_cast - на этапе компиляции позволяет делать преобразования арифметических типов
например float в int или long в int. или преобразования типов в одной иерархии наследования.
reinterpret_cast - адрес в памяти считается выбранного типа, например int в void*,
результирующим типом можно корректно пользоваться только если он есть тип которым
была инициализирована переменная.
dynamic_cast - преобразует полиморфные типы в рантайме, если не получается преобразовать
возвращает nullptr
(T)e - выражение доставшееся в наследство от С, означает комбинацию static_cast, reinterpret_cast
и const_cast - чтобы получить заданный тип T.

74) 
struct A
{
int val() { return val; }
int do() { return val++;}
int val = 0;
};
A a;
std::cout << a.val() << a.do() << a.val;
Результат вывода не определен, потому что промежуточные значения в выражении
могут вычисляться в угодном компилятору порядке.

75) запись T(e) может быть конструктором, но для арифметических типов она равнозначна
записи (T)e, что есть очень печально, потому что это получается уже Сишное приведение типов.

76) нельзя преобразовать int в указатель: char*(2), но это можно обойти через typedef
КАК ЭТО МОЖНО ОБОЙТИ? НАПИСАТЬ ПРИМЕР!
для арифметических типов дефолтное значение 0, поэтому можно написать int a = int();
переменная a инициализируется нулем, может быть полезно для использования в шаблонах,
где не известно пользовательский тип или арифметический будет передан на вход.

77) вся инициализация в одном стиле через фигурные скобки! знак =(равно) необязателен
int a = {0};
struct A{ int a[3] A(int x, int y, int z):a{x,y,x}()};

78) rvalue - временные объекты, которые жизненный цикл которых - одно выражение
lvalue - все объекты которые живут дольше чем в одном выражении.

79) можно объявить rvalue как X && x = getX();
причем нельзя передать rvalue в ссылку для lvalue.
нужно помнить про операторы перемещения и про функцию std::move,
которая перемещает значение из одной переменной в другую
X a;
X f();
X& r1 = a;	// связывает r1 с a (lvalue)
X& r2 = f();	// ОШИБКА: rvalue
X&& rr1 = f();	// ok: связывает rr1 с временным объектом
X&& rr2 = a;	// ошибка: a – это lvalue

80) правило 3-х:
сделал кастомный деструктор/конструктор копирования/оператор присваивания,
добавь оставшиеся из этих 3-х.
суть в том, что если стандартная реализация чего-то одного не подошло,
скорее всего реализации остальных тоже не подойдут.
С++ 11, повилось правило 5-ти, стоит также добавить конструктор и оператор перемещения.

81) union - набор данных который был сделан с целью экономии памяти.
union хранит в себе несколько типов, но каждый из них начинается с одного и того же
адреса в памяти. таким образом записав значение в один из типов, потеряются значения в других.
есть проблемы связанные с пользовательскими конструкторами и деструкторами.
Возможна ситуация когда несколько конструкторов переопределены и непонятно какой из них
вызывать при инициализации union. такая же ситуация с деструктором. в С++ 11 ввели возможность
добавлять подобные типы в объединения и в них нужно будет явно вызывать деструктор.
ЕЩЕ РАЗ НАЙТИ КАКИЕ ТИПЫ МОЖНО ЗАПИХАТЬ В ЮНИОНЫ!!!

